#Backbone.js ... la suite

##Introduction

Nous avions eu la dernière fois [une petite intro à Backbone](https://github.com/k33g/articles/blob/master/2011-07-19-BACKBONE.md). Par contre la façon de coder n'a pas forcément était faite dans les règles de l'art, pour partie à dessein (aspect didactique : pas la peine de vous pourrir avec certaines bonnes pratiques qui peuvent rendre le code obscur à un débutant) et pour le reste, ... faut bien apprendre ;)

Aujourd'hui, j'ajoute donc ces bonnes pratiques, plus celles issues de l'aimable relecture de [@mklabs](http://twitter.com/mklabs/). (je vais même repomper complètement certaines de ses phrases).

##C'est parti !

###HTML

Nous allons modifier tout d'abord le code HTML, pour être un peu plus pro. Donc, nous avions anciennement ceci :

~~~ html
    <a href="#showAbout" id="lnkAbout">about</a>
    <div id="divClient">
        Identifiant : <input type="text" id="txtIdClient" placeholder="identifiant du client">
        &nbsp; Client : <input type="text" id="txtNomClient" placeholder="nom du client">
        &nbsp; Remarque : <input type="text" id="txtRemarqueClient" placeholder="remarque sur le client" size="50">
        &nbsp; <button id="cmdAddClient">Ajouter Client</button>
        <br>
        <ul id="listeClient"></ul>
    </div>

    <div id="divAbout">Ceci est un tuto sur BackBone</div>
~~~

Que nous allons transformer en ceci :

~~~ html

~~~



###Global

Comme dit [@mklabs](http://twitter.com/mklabs/), *"faut éviter la fête du Global"*. Et il n'a pas complètement tort, de tout temps, la variable publique, c'est pas propre!

Pour cela il faut inclure notre code applicatif dans une closure :

~~~ javascript
    (function($, exports){
        //ici notre code applicatif
    })(this.Zepto, this);
~~~

*bien sur, si on utilise jQuery, nous aurons this.jQuery en lieu et place de this.Zepto*

###OnLoad

On doit lancer l'application uniquement quand la page est complètement chargée. Donc, on remplace

~~~ javascript
    /*--- initialisation de la webapp ---*/
    var myApp = new Workspace();

    /*--- activation du monitoring des "hashchange events" et dispatch des routes ---*/
    Backbone.history.start();
~~~

par

~~~ javascript
    $(function() {
        /*--- initialisation de la webapp ---*/
        var myApp = new Workspace();

        /*--- activation du monitoring des "hashchange events" et dispatch des routes ---*/
        Backbone.history.start();
    });
~~~

###Model

- C'est pas super propre d'initialiser les membres à null (ça ce discute)
- Quitte à faire d'utiliser BackBone, utiliser la fonctionnalité de validation du Model (méthode `validate` du model)

Donc :

~~~ javascript
    /*--- Model ---*/
    var Client = Backbone.Model.extend({
        defaults : {
            id : null,
            nom : null,
            remarque : null
        },

        initialize : function() {
            console.log("initialize client");
        }
    });
~~~

devient :

~~~ javascript
    /*--- Model ---*/
    var Client = Backbone.Model.extend({
        defaults : {
            id : 'Identifiant du client',
            nom: 'Nom du client',
            remarque: 'Remarque sur le client'
        },

        validate: function(attrs) {
            if(!attrs.id) return new Error('ID absent');
            if(!attrs.nom) return new Error('Nom absent');
            if(!attrs.remarque) return 'Remarque absente';
        },

        initialize : function() {
            console.log("initialize client");
        }
    });
~~~

###View

Alors, je le redis, c'est le concept de View, selon Backbone. concernant la vue, gros changements, donc je vais laisser l'ancien code en commentaires pour bien montrer les différences :

~~~ javascript

~~~
